<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Trash Separator</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Puter JS -->
    <script src="https://js.puter.com/v2/"></script>
    <style>
        /* Minimal custom CSS - mostly handled by Tailwind */
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        /* Spinner animation */
        .spinner {
            border: 5px solid rgba(0, 0, 0, 0.1);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border-left-color: #22c55e; /* Tailwind green-500 */
            animation: spin 1s ease infinite;
            margin: 30px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Custom scrollbar for history modal (optional) */
        #history-modal-body::-webkit-scrollbar {
            width: 8px;
        }
        #history-modal-body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #history-modal-body::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #history-modal-body::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

    </style>
</head>

<body class="bg-gray-50 text-gray-800 p-4 sm:p-6">
    <div class="container max-w-xl mx-auto">

        <h1 class="text-center text-2xl sm:text-3xl font-bold mb-5 text-green-700 app-title">
            <i class="fas fa-recycle mr-2"></i><span id="app-title-text">Smart Trash Separator</span>
        </h1>

        <!-- Settings -->
        <div class="settings-container bg-white p-4 rounded-lg shadow-sm mb-6 flex flex-col sm:flex-row justify-between items-center space-y-3 sm:space-y-0 sm:space-x-4">
            <div class="setting-group w-full sm:w-auto flex items-center space-x-2">
                <label for="language-select" id="language-label" class="text-sm font-medium text-gray-700">Language:</label>
                <select id="language-select" class="block w-full border-gray-300 rounded-md shadow-sm focus:border-green-500 focus:ring-green-500 text-sm py-1.5 px-2">
                    <option value="en">English</option>
                    <option value="de">Deutsch</option>
                    <option value="it">Italiano</option>
                    <option value="pt">Português (Brasil)</option> <!-- Added Portuguese -->
                </select>
            </div>
            <div class="setting-group w-full sm:w-auto flex items-center space-x-2">
                <label for="country-select" id="country-label" class="text-sm font-medium text-gray-700">Region:</label>
                <select id="country-select" class="block w-full border-gray-300 rounded-md shadow-sm focus:border-green-500 focus:ring-green-500 text-sm py-1.5 px-2">
                    <option value="us">United States</option>
                    <option value="de">Germany</option>
                    <option value="it">Italy</option>
                    <option value="br">Brazil</option> <!-- Added Brazil -->
                </select>
            </div>
            <button id="history-button" class="w-full sm:w-auto px-3 py-1.5 bg-gray-500 hover:bg-gray-600 text-white text-sm font-medium rounded-md shadow-sm flex items-center justify-center space-x-1.5 transition duration-150">
                <i class="fas fa-history"></i>
                <span id="history-button-text">Scan History</span>
            </button>
        </div>

        <!-- Instructions -->
        <div class="instructions-box bg-green-50 border-l-4 border-green-500 p-4 rounded-r-md mb-6 text-sm text-green-800">
            <p id="instructions-text"><strong>How to use:</strong> Point your camera at an item, then tap "Identify Item". The app will show you the correct bin.</p>
        </div>

        <!-- Camera -->
        <div id="camera-container" class="relative w-full max-w-md mx-auto mb-6 rounded-xl overflow-hidden shadow-lg bg-gray-300 aspect-video">
            <video id="camera" playsinline autoplay muted class="block w-full h-full object-cover"></video>
            <div id="camera-overlay" class="absolute inset-0 border-4 border-dashed border-green-500 rounded-xl pointer-events-none box-border"></div>
            <!-- Snapshot overlay will be added here by JS -->
        </div>

        <!-- Scan Button -->
        <div class="button-container text-center mb-6">
            <button id="scan-button" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-8 rounded-full shadow-md transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center mx-auto text-lg" disabled>
                <i class="fas fa-camera mr-2"></i>
                <span id="scan-button-text">Identify Item</span>
            </button>
        </div>

        <!-- Output Area (Spinner/Errors outside card) -->
        <div id="output" aria-live="polite" class="text-center min-h-[50px]">
            <!-- Spinner or generic error messages appear here -->
        </div>

        <!-- Result Card -->
        <div id="result-card" class="bg-white rounded-xl shadow-xl mt-8 overflow-hidden hidden" aria-live="polite">
            <!-- Bin Header: Class and content set by JS -->
            <div id="bin-header" class="bin-header flex flex-col items-center justify-center p-6 text-white text-center min-h-[180px]">
                <!-- Icon, Bin Name, Material Summary dynamically added here -->
            </div>
            <!-- Item Details -->
            <div class="item-details p-6">
                <div id="item-name" class="item-name text-2xl font-semibold mb-2 text-gray-900">
                    <!-- Item name will appear here -->
                </div>
                <!-- Dynamic result elements will be inserted here by JS -->
                <div id="bin-instructions" class="bin-instructions text-base font-medium mt-4 mb-3 p-4 rounded-r-md border-l-4" style="display: none;">
                    <!-- Bin instructions will appear here (hidden initially) -->
                </div>
                <hr id="details-hr" class="my-4" style="display: none;">
                <div id="item-description" class="item-description text-sm text-gray-600 mb-4">
                    <!-- Item description (AI reasoning) will appear here -->
                </div>
                 <!-- Feedback Buttons will be inserted here by JS -->
                <div id="country-note" class="country-note text-xs text-gray-500 mt-4" style="display: none;">
                    <!-- Country-specific note area (currently hidden) -->
                </div>
            </div>
        </div>

        <!-- History Modal -->
        <div id="history-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4 hidden">
             <div class="modal-content bg-white rounded-lg shadow-2xl max-w-2xl w-full mx-auto max-h-[85vh] flex flex-col">
                 <div class="flex justify-between items-center p-4 border-b border-gray-200">
                      <h2 id="history-modal-title" class="text-xl font-semibold text-gray-800">Scan History</h2>
                      <button class="close-button text-gray-400 hover:text-gray-600 text-2xl font-bold" onclick="toggleHistoryModal(false)">×</button>
                 </div>
                 <div id="history-modal-body" class="p-4 overflow-y-auto flex-grow">
                     <!-- History items will be loaded here -->
                     <p id="history-empty-message" class="text-center text-gray-500 py-8">No scans recorded yet.</p>
                 </div>
                  <div class="p-3 bg-gray-50 border-t border-gray-200 text-right">
                      <button onclick="toggleHistoryModal(false)" class="px-4 py-2 bg-gray-200 text-gray-700 text-sm font-medium rounded-md hover:bg-gray-300 transition">Close</button>
                  </div>
             </div>
         </div>

    </div> <!-- End container -->

    <script>
        // --- DOM Elements ---
        const video = document.getElementById('camera');
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const scanButton = document.getElementById('scan-button');
        const outputDiv = document.getElementById('output');
        const resultCard = document.getElementById('result-card');
        const binHeader = document.getElementById('bin-header');
        const itemName = document.getElementById('item-name');
        const itemDescription = document.getElementById('item-description');
        const binInstructions = document.getElementById('bin-instructions');
        const countryNote = document.getElementById('country-note');
        const languageSelect = document.getElementById('language-select');
        const countrySelect = document.getElementById('country-select');
        const historyModal = document.getElementById('history-modal');
        const historyButton = document.getElementById('history-button');
        const detailsHr = document.getElementById('details-hr');

        // --- App State ---
        let userCountry = 'us';
        let currentLanguage = 'en';
        let lastAIResponse = null;
        let lastResultItems = null;
        let lastImageDataUrl = null;

        // --- Tailwind Color Mappings ---
        const binColorClasses = {
            'us-recyclable': 'bg-blue-600',
            'us-organic': 'bg-green-600',
            'us-general-waste': 'bg-gray-700',
            'us-hazardous': 'bg-red-600',
            'de-recyclable-yellow': 'bg-yellow-500',
            'de-recyclable-paper': 'bg-blue-500',
            'de-organic': 'bg-lime-600', // Adjusted from brown/green to lime for distinction
            'de-general-waste': 'bg-gray-800',
            'de-hazardous': 'bg-red-500',
            'it-recyclable-plastic_metal': 'bg-yellow-400',
            'it-recyclable-paper': 'bg-blue-500',
            'it-recyclable-glass': 'bg-green-600',
            'it-organic': 'bg-amber-800', // Changed from yellow-800 to avoid clash
            'it-general-waste': 'bg-slate-500',
            'it-hazardous': 'bg-red-700',
            'br-recyclable-paper': 'bg-blue-500',
            'br-recyclable-plastic': 'bg-red-500',
            'br-recyclable-glass': 'bg-green-600',
            'br-recyclable-metal': 'bg-yellow-400',
            'br-organic': 'bg-amber-800', // Using brown-ish color
            'br-general-waste': 'bg-gray-700',
            'br-hazardous': 'bg-orange-500', // Orange is common for hazardous in Brazil
            'default-recyclable': 'bg-blue-500',
            'default-organic': 'bg-green-500',
            'default-general-waste': 'bg-gray-500',
            'default-hazardous': 'bg-red-500',
            'error-bin': 'bg-gray-400'
        };
        const binBorderColorClasses = {
             'us-recyclable': 'border-blue-600',
             'us-organic': 'border-green-600',
             'us-general-waste': 'border-gray-700',
             'us-hazardous': 'border-red-600',
             'de-recyclable-yellow': 'border-yellow-500',
             'de-recyclable-paper': 'border-blue-500',
             'de-organic': 'border-lime-600',
             'de-general-waste': 'border-gray-800',
             'de-hazardous': 'border-red-500',
             'it-recyclable-plastic_metal': 'border-yellow-400',
             'it-recyclable-paper': 'border-blue-500',
             'it-recyclable-glass': 'border-green-600',
             'it-organic': 'border-amber-800',
             'it-general-waste': 'border-slate-500',
             'it-hazardous': 'border-red-700',
             'br-recyclable-paper': 'border-blue-500',
             'br-recyclable-plastic': 'border-red-500',
             'br-recyclable-glass': 'border-green-600',
             'br-recyclable-metal': 'border-yellow-400',
             'br-organic': 'border-amber-800',
             'br-general-waste': 'border-gray-700',
             'br-hazardous': 'border-orange-500',
             'default-recyclable': 'border-blue-500',
             'default-organic': 'border-green-500',
             'default-general-waste': 'border-gray-500',
             'default-hazardous': 'border-red-500',
             'error-bin': 'border-gray-400'
        };

        // --- Translations ---
        const translations = {
            en: {
                appTitle: "Smart Trash Separator", languageLabel: "Language:", countryLabel: "Region:", instructionsTitle: "How to use:", instructionsText: "Point your camera at an item, then tap \"Identify Item\". The app will show you the correct bin.", scanButtonText: "Identify Item", errorCameraNotFound: "Camera not found. Please ensure a camera is connected and enabled.", errorCameraDenied: "Camera access denied. Please grant permission in your browser settings.", errorCameraInit: "Failed to initialize camera. Please try again.", errorAIResponse: "Received an unclear response from AI. Please try again.", errorAIStructure: "Received invalid response structure or empty content from AI.", errorAIAnalyze: "Error analyzing item:", errorUnknownAI: "Unknown AI error. Please try again.", errorCapture: "Could not capture image or prepare AI call. Please try again.", aiAnalysisPrefix: "AI Analysis:", aiConfidencePrefix: "Confidence:", aiSecondaryGuessPrefix: "Also consider:", aiPositionPrefix: "Detected at:", aiContaminatedWarning: "Item appears contaminated. May need to go in General Waste.", feedbackCorrect: "Correct", feedbackIncorrect: "Incorrect", multipleItemsDetected: "Multiple items detected. Showing details for the primary item.", historyButtonText: "Scan History", historyModalTitle: "Scan History", historyEmptyMessage: "No scans recorded yet.", errorAINoItemFound: "Could not clearly identify an item.", binNameError: "Identification Failed", instructionError: "Please try again with a clearer image or different angle.", instructionCheckLocal: "Check local guidelines for specific rules.",
                // Generic Bin Names (Fallbacks)
                binRecycling: "Recycling Bin", binOrganic: "Organics / Compost", binHazardous: "Hazardous Waste", binGeneral: "Trash / Landfill",
                // Generic Material Names (Fallbacks)
                materialRecyclable: "Recyclable Material", materialOrganic: "Organic Material", materialHazardous: "Hazardous Material", materialMixed: "Mixed/Non-Recyclable", materialPaper: "Paper/Cardboard", materialPlastic: "Plastic", materialGlass: "Glass", materialMetal: "Metal",
                // US Specific
                binNameRecyclingUS: "Recycling Bin", binNameOrganicUS: "Organics / Compost Bin", binNameHazardousUS: "Hazardous Waste Drop-off", binNameGeneralUS: "Trash / Landfill Bin",
                instructionRecyclingUS: "Place in the BLUE Recycling Bin. Accepts clean paper, cardboard, plastic bottles/jugs, metal cans, glass (check local rules).", instructionOrganicUS: "Place in the GREEN Organics Bin. Accepts food scraps, yard waste.", instructionHazardousUS: "HAZARDOUS WASTE: DO NOT put in trash/recycling. Take to a designated {binName}.", instructionGeneralUS: "Place in the BLACK/GRAY Trash Bin (Landfill).", instructionContaminatedRecyclableUS: "Item appears contaminated. Place in the {binName} instead.",
                // DE Specific
                binNameRecyclingDE_Yellow: "Gelbe Tonne / Sack (Packaging)", binNameRecyclingDE_Blue: "Papiertonne (Paper)", binNameOrganicDE: "Biotonne (Organic)", binNameHazardousDE: "Sondermüll (Hazardous)", binNameGeneralDE: "Restmülltonne (General Waste)",
                instructionRecyclingDE_Yellow: "Bitte in die GELBE TONNE/SACK (Verpackungen). Leichtverpackungen aus Kunststoff, Metall, Verbundstoffen.", instructionRecyclingDE_Blue: "Bitte in die BLAUE TONNE (Papier/Karton).", instructionOrganicDE: "Bitte in die BRAUNE oder GRÜNE TONNE (Biomüll). Essensreste, Gartenabfälle.", instructionHazardousDE: "SONDERMÜLL: Nicht in den Hausmüll! Bitte zum Wertstoffhof oder Schadstoffmobil bringen.", instructionGeneralDE: "Bitte in die SCHWARZE oder GRAUE TONNE (Restmüll).", instructionContaminatedRecyclableDE: "Gegenstand scheint verschmutzt. Stattdessen in die {binName} geben.",
                // IT Specific
                binNameRecyclingIT_Yellow: "Plastica e Metalli (Plastic & Metal)", binNameRecyclingIT_Blue: "Carta e Cartone (Paper)", binNameRecyclingIT_Green: "Vetro (Glass)", binNameOrganicIT: "Organico / Umido (Organic)", binNameHazardousIT: "Rifiuti Pericolosi (Hazardous)", binNameGeneralIT: "Secco Residuo / Indifferenziata (General Waste)",
                instructionRecyclingIT_Yellow: "Getta nel contenitore GIALLO (Plastica e Metalli). Svuotati e schiacciati se possibile.", instructionRecyclingIT_Blue: "Getta nel contenitore BLU (Carta e Cartone). Pulito e asciutto.", instructionRecyclingIT_Green: "Getta nel contenitore VERDE (Vetro). Senza tappo, svuotato.", instructionOrganicIT: "Getta nel contenitore MARRONE (Organico/Umido). Scarti di cibo, rifiuti giardino.", instructionHazardousIT: "RIFIUTI PERICOLOSI (es. Pile, Farmaci): Portare ai punti di raccolta dedicati o farmacie.", instructionGeneralIT: "Getta nel contenitore GRIGIO (Secco Residuo / Indifferenziata).", instructionContaminatedRecyclableIT: "L'oggetto sembra contaminato. Gettare invece nel {binName}.",
                // BR Specific (Add later in PT translation)
             },
            de: { /* ... German translations ... existing ... */
                appTitle: "Intelligenter Müllsortierer", languageLabel: "Sprache:", countryLabel: "Region:", instructionsTitle: "Anleitung:", instructionsText: "Richten Sie Ihre Kamera auf einen Gegenstand und tippen Sie auf \"Gegenstand erkennen\". Die App zeigt Ihnen den richtigen Behälter.", scanButtonText: "Gegenstand erkennen", errorCameraNotFound: "Kamera nicht gefunden. Stellen Sie sicher, dass eine Kamera angeschlossen und aktiviert ist.", errorCameraDenied: "Kamerazugriff verweigert. Bitte erteilen Sie die Berechtigung in Ihren Browsereinstellungen.", errorCameraInit: "Kamera konnte nicht initialisiert werden. Bitte versuchen Sie es erneut.", errorAIResponse: "Unklare Antwort von der KI erhalten. Bitte versuchen Sie es erneut.", errorAIStructure: "Ungültige Antwortstruktur oder leerer Inhalt von der KI erhalten.", errorAIAnalyze: "Fehler bei der Analyse des Gegenstands:", errorUnknownAI: "Unbekannter KI-Fehler. Bitte versuchen Sie es erneut.", errorCapture: "Bild konnte nicht aufgenommen oder KI-Aufruf vorbereitet werden. Bitte versuchen Sie es erneut.", aiAnalysisPrefix: "KI-Analyse:", aiConfidencePrefix: "Konfidenz:", aiSecondaryGuessPrefix: "Auch berücksichtigen:", aiPositionPrefix: "Erkannt bei:", aiContaminatedWarning: "Gegenstand scheint verschmutzt. Muss möglicherweise in den Restmüll.", feedbackCorrect: "Korrekt", feedbackIncorrect: "Falsch", multipleItemsDetected: "Mehrere Gegenstände erkannt. Details für den Hauptgegenstand werden angezeigt.", historyButtonText: "Verlauf", historyModalTitle: "Scan-Verlauf", historyEmptyMessage: "Noch keine Scans aufgezeichnet.", errorAINoItemFound: "Gegenstand konnte nicht eindeutig identifiziert werden.", binNameError: "Identifizierung fehlgeschlagen", instructionError: "Bitte versuchen Sie es mit einem klareren Bild oder einem anderen Winkel erneut.", instructionCheckLocal: "Lokale Richtlinien auf spezifische Regeln prüfen.",
                // Generic Bin Names (Fallbacks)
                binRecycling: "Recyclingtonne", binOrganic: "Biotonne", binHazardous: "Sondermüll", binGeneral: "Restmüll",
                // Generic Material Names (Fallbacks)
                materialRecyclable: "Recyclebares Material", materialOrganic: "Organisches Material", materialHazardous: "Gefahrstoff", materialMixed: "Gemischt/Nicht recyclebar", materialPaper: "Papier/Karton", materialPlastic: "Plastik/Kunststoff", materialGlass: "Glas", materialMetal: "Metall",
                // DE Specific (Bin Names match keys)
                binNameRecyclingDE_Yellow: "Gelbe Tonne / Sack (Verpackung)", binNameRecyclingDE_Blue: "Papiertonne (Papier)", binNameOrganicDE: "Biotonne (Bioabfall)", binNameHazardousDE: "Sondermüll", binNameGeneralDE: "Restmülltonne",
                instructionRecyclingDE_Yellow: "Bitte in die GELBE TONNE/SACK (Verpackungen). Leichtverpackungen aus Kunststoff, Metall, Verbundstoffen.", instructionRecyclingDE_Blue: "Bitte in die BLAUE TONNE (Papier/Karton).", instructionOrganicDE: "Bitte in die BRAUNE oder GRÜNE TONNE (Biomüll). Essensreste, Gartenabfälle.", instructionHazardousDE: "SONDERMÜLL: Nicht in den Hausmüll! Bitte zum Wertstoffhof oder Schadstoffmobil bringen.", instructionGeneralDE: "Bitte in die SCHWARZE oder GRAUE TONNE (Restmüll).", instructionContaminatedRecyclableDE: "Gegenstand scheint verschmutzt. Stattdessen in die {binName} geben.",
             },
            it: { /* ... Italian translations ... existing ... */
                appTitle: "Separatore Rifiuti Intelligente", languageLabel: "Lingua:", countryLabel: "Regione:", instructionsTitle: "Come usare:", instructionsText: "Punta la fotocamera verso un oggetto, poi tocca \"Identifica Oggetto\". L'app ti mostrerà il bidone corretto.", scanButtonText: "Identifica Oggetto", errorCameraNotFound: "Fotocamera non trovata. Assicurati che sia collegata e abilitata.", errorCameraDenied: "Accesso alla fotocamera negato. Concedi l'autorizzazione nelle impostazioni del browser.", errorCameraInit: "Inizializzazione fotocamera fallita. Riprova.", errorAIResponse: "Risposta non chiara ricevuta dall'IA. Riprova.", errorAIStructure: "Struttura della risposta non valida o contenuto vuoto ricevuto dall'IA.", errorAIAnalyze: "Errore durante l'analisi dell'oggetto:", errorUnknownAI: "Errore IA sconosciuto. Riprova.", errorCapture: "Impossibile catturare l'immagine o preparare la chiamata IA. Riprova.", aiAnalysisPrefix: "Analisi IA:", aiConfidencePrefix: "Confidenza:", aiSecondaryGuessPrefix: "Considera anche:", aiPositionPrefix: "Rilevato a:", aiContaminatedWarning: "L'oggetto sembra contaminato. Potrebbe dover andare nei Rifiuti Generici.", feedbackCorrect: "Corretto", feedbackIncorrect: "Errato", multipleItemsDetected: "Rilevati più oggetti. Mostrando i dettagli per l'oggetto principale.", historyButtonText: "Cronologia", historyModalTitle: "Cronologia Scansioni", historyEmptyMessage: "Nessuna scansione registrata.", errorAINoItemFound: "Impossibile identificare chiaramente un oggetto.", binNameError: "Identificazione Fallita", instructionError: "Per favore, riprova con un'immagine più chiara o un'angolazione diversa.", instructionCheckLocal: "Verifica le linee guida locali per regole specifiche.",
                // Generic Bin Names (Fallbacks)
                binRecycling: "Bidone Riciclabili", binOrganic: "Bidone Organico", binHazardous: "Rifiuti Pericolosi", binGeneral: "Bidone Indifferenziata",
                // Generic Material Names (Fallbacks)
                materialRecyclable: "Materiale Riciclabile", materialOrganic: "Materiale Organico", materialHazardous: "Materiale Pericoloso", materialMixed: "Misto/Non Riciclabile", materialPaper: "Carta/Cartone", materialPlastic: "Plastica", materialGlass: "Vetro", materialMetal: "Metallo",
                // IT Specific (Bin Names match keys)
                binNameRecyclingIT_Yellow: "Plastica e Metalli", binNameRecyclingIT_Blue: "Carta e Cartone", binNameRecyclingIT_Green: "Vetro", binNameOrganicIT: "Organico / Umido", binNameHazardousIT: "Rifiuti Pericolosi", binNameGeneralIT: "Secco Residuo / Indifferenziata",
                instructionRecyclingIT_Yellow: "Getta nel contenitore GIALLO (Plastica e Metalli). Svuotati e schiacciati se possibile.", instructionRecyclingIT_Blue: "Getta nel contenitore BLU (Carta e Cartone). Pulito e asciutto.", instructionRecyclingIT_Green: "Getta nel contenitore VERDE (Vetro). Senza tappo, svuotato.", instructionOrganicIT: "Getta nel contenitore MARRONE (Organico/Umido). Scarti di cibo, rifiuti giardino.", instructionHazardousIT: "RIFIUTI PERICOLOSI (es. Pile, Farmaci): Portare ai punti di raccolta dedicati o farmacie.", instructionGeneralIT: "Getta nel contenitore GRIGIO (Secco Residuo / Indifferenziata).", instructionContaminatedRecyclableIT: "L'oggetto sembra contaminato. Gettare invece nel {binName}.",
             },
            pt: { // Added Portuguese (Brazil) translations
                appTitle: "Separador Inteligente de Lixo", languageLabel: "Idioma:", countryLabel: "Região:", instructionsTitle: "Como usar:", instructionsText: "Aponte sua câmera para um item e toque em \"Identificar Item\". O app mostrará a lixeira correta.", scanButtonText: "Identificar Item", errorCameraNotFound: "Câmera não encontrada. Verifique se uma câmera está conectada e habilitada.", errorCameraDenied: "Acesso à câmera negado. Por favor, conceda permissão nas configurações do seu navegador.", errorCameraInit: "Falha ao inicializar a câmera. Por favor, tente novamente.", errorAIResponse: "Resposta da IA pouco clara. Por favor, tente novamente.", errorAIStructure: "Estrutura de resposta inválida ou conteúdo vazio recebido da IA.", errorAIAnalyze: "Erro ao analisar o item:", errorUnknownAI: "Erro desconhecido da IA. Por favor, tente novamente.", errorCapture: "Não foi possível capturar a imagem ou preparar a chamada da IA. Por favor, tente novamente.", aiAnalysisPrefix: "Análise da IA:", aiConfidencePrefix: "Confiança:", aiSecondaryGuessPrefix: "Considere também:", aiPositionPrefix: "Detectado em:", aiContaminatedWarning: "Item parece contaminado. Pode precisar ir para o Lixo Comum/Rejeito.", feedbackCorrect: "Correto", feedbackIncorrect: "Incorreto", multipleItemsDetected: "Múltiplos itens detectados. Mostrando detalhes do item principal.", historyButtonText: "Histórico", historyModalTitle: "Histórico de Escaneamentos", historyEmptyMessage: "Nenhum escaneamento registrado ainda.", errorAINoItemFound: "Não foi possível identificar um item claramente.", binNameError: "Falha na Identificação", instructionError: "Por favor, tente novamente com uma imagem mais clara ou ângulo diferente.", instructionCheckLocal: "Verifique as diretrizes locais para regras específicas.",
                // Generic Bin Names (Fallbacks)
                binRecycling: "Reciclável", binOrganic: "Orgânico", binHazardous: "Resíduo Perigoso", binGeneral: "Lixo Comum / Rejeito",
                // Generic Material Names (Fallbacks)
                materialRecyclable: "Material Reciclável", materialOrganic: "Material Orgânico", materialHazardous: "Material Perigoso", materialMixed: "Misto/Não Reciclável", materialPaper: "Papel/Papelão", materialPlastic: "Plástico", materialGlass: "Vidro", materialMetal: "Metal",
                // BR Specific (Bin Names match keys)
                binNameRecyclingBR_Paper: "Lixeira Azul (Papel)", binNameRecyclingBR_Plastic: "Lixeira Vermelha (Plástico)", binNameRecyclingBR_Glass: "Lixeira Verde (Vidro)", binNameRecyclingBR_Metal: "Lixeira Amarela (Metal)", binNameOrganicBR: "Lixeira Marrom (Orgânico)", binNameHazardousBR: "Lixo Perigoso (Descarte Especial)", binNameGeneralBR: "Lixeira Cinza (Rejeito / Não Reciclável)",
                instructionRecyclingBR_Paper: "Coloque na LIXEIRA AZUL (Papel). Jornais, revistas, caixas de papelão, embalagens de papel limpas.", instructionRecyclingBR_Plastic: "Coloque na LIXEIRA VERMELHA (Plástico). Garrafas PET, embalagens plásticas limpas, potes.", instructionRecyclingBR_Glass: "Coloque na LIXEIRA VERDE (Vidro). Garrafas de vidro, potes de vidro, frascos. Limpos e sem tampa.", instructionRecyclingBR_Metal: "Coloque na LIXEIRA AMARELA (Metal). Latas de alumínio (refrigerante, cerveja), latas de aço (óleo, sardinha), tampinhas, arames.", instructionOrganicBR: "Coloque na LIXEIRA MARROM (Orgânico). Restos de comida (frutas, vegetais, carnes), cascas de ovos, borra de café, resíduos de jardim.", instructionHazardousBR: "RESÍDUO PERIGOSO: NÃO jogue no lixo comum ou reciclável! Leve a um ponto de coleta especial (pilhas, baterias, lâmpadas, eletrônicos, tintas).", instructionGeneralBR: "Coloque na LIXEIRA CINZA (Rejeito). Lixo de banheiro (papel higiênico), fraldas, absorventes, etiquetas adesivas, fotografias, esponjas usadas, itens contaminados.", instructionContaminatedRecyclableBR: "Item parece contaminado. Coloque na {binName} (Rejeito) em vez disso.",
             }
        };

        // --- UI Update Functions ---
        function showSpinner() {
            outputDiv.innerHTML = '<div class="spinner"></div>';
            resultCard.classList.add('hidden');
            scanButton.disabled = true;
        }

        function hideSpinner() {
            outputDiv.innerHTML = '';
            scanButton.disabled = false; // Re-enable button after attempt
        }

        function displayError(messageKey, detail = '') {
             // This function displays errors *outside* the result card (e.g., camera failure)
             const lang = currentLanguage;
             const message = translations[lang]?.[messageKey] || translations.en[messageKey] || messageKey;
             outputDiv.innerHTML = `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                                      <strong class="font-bold">Error:</strong>
                                      <span class="block sm:inline">${message} ${detail}</span>
                                    </div>`;
             resultCard.classList.add('hidden'); // Ensure card is hidden on generic error
             scanButton.disabled = false;
        }

        // Helper to generate bin details
        function generateBinDetails(binType, material, country) {
            // Default values
            let binColorClassKey = 'default-general-waste';
            let regionalBinName = 'General Waste'; // Fallback name in English
            let uiBinName = 'General Waste'; // Fallback name in English
            let binIconClass = 'fa-trash-alt';
            let headerMaterialSummary = 'Mixed/Non-Recyclable'; // Fallback name in English
            let binNameKey = 'binGeneral'; // Key for translation lookup
            let specificInstructionKey = 'instructionGeneral'; // Key for specific instruction text

            const t_region_en = translations.en; // Use English base for structure
            const t_ui = translations[currentLanguage] || translations.en;
            const t_region_specific = translations[country] || translations.en; // Translations for the *selected region*

            // Determine Material Summary (in UI language) - Use UI language keys first
            const materialLower = material ? material.toLowerCase() : '';
            if (materialLower.includes('paper') || materialLower.includes('cardboard')) {
                headerMaterialSummary = t_ui.materialPaper || t_region_en.materialPaper;
            } else if (materialLower.includes('glass')) {
                headerMaterialSummary = t_ui.materialGlass || t_region_en.materialGlass;
            } else if (materialLower.includes('plastic') || materialLower.includes('pet')) {
                headerMaterialSummary = t_ui.materialPlastic || t_region_en.materialPlastic;
            } else if (materialLower.includes('metal') || materialLower.includes('aluminum') || materialLower.includes('steel')) {
                 headerMaterialSummary = t_ui.materialMetal || t_region_en.materialMetal;
            } else if (materialLower.includes('food') || materialLower.includes('organic')) {
                headerMaterialSummary = t_ui.materialOrganic || t_region_en.materialOrganic;
            } else if (materialLower.includes('hazard') || materialLower.includes('toxic') || binType === 'hazardous') {
                 headerMaterialSummary = t_ui.materialHazardous || t_region_en.materialHazardous;
            } else if (binType === 'organic') {
                 headerMaterialSummary = t_ui.materialOrganic || t_region_en.materialOrganic;
            } else if (binType === 'recyclable') {
                 // If recyclable but no specific material, use generic term
                 headerMaterialSummary = t_ui.materialRecyclable || t_region_en.materialRecyclable;
            } else { // General waste or unspecified
                headerMaterialSummary = t_ui.materialMixed || t_region_en.materialMixed;
            }


            // Set bin class, name, icon, and instruction key based on bin type, material hint, and country
            if (country === 'br') { // Brazil Specific Logic
                switch(binType) {
                    case 'recyclable':
                        if (materialLower.includes('paper') || materialLower.includes('cardboard')) {
                            binColorClassKey = 'br-recyclable-paper';
                            binNameKey = 'binNameRecyclingBR_Paper';
                            binIconClass = 'fa-file-alt'; // Paper icon
                            specificInstructionKey = 'instructionRecyclingBR_Paper';
                        } else if (materialLower.includes('plastic') || materialLower.includes('pet')) {
                            binColorClassKey = 'br-recyclable-plastic';
                            binNameKey = 'binNameRecyclingBR_Plastic';
                            binIconClass = 'fa-bottle-water'; // Plastic icon
                            specificInstructionKey = 'instructionRecyclingBR_Plastic';
                        } else if (materialLower.includes('glass')) {
                            binColorClassKey = 'br-recyclable-glass';
                            binNameKey = 'binNameRecyclingBR_Glass';
                            binIconClass = 'fa-wine-bottle'; // Glass icon
                            specificInstructionKey = 'instructionRecyclingBR_Glass';
                        } else if (materialLower.includes('metal') || materialLower.includes('aluminum') || materialLower.includes('steel')) {
                            binColorClassKey = 'br-recyclable-metal';
                            binNameKey = 'binNameRecyclingBR_Metal';
                            binIconClass = 'fa-缶'; // Placeholder for can/metal icon, fa-gear or fa-cogs could work
                            specificInstructionKey = 'instructionRecyclingBR_Metal';
                        } else { // Generic recyclable if material unknown/unmatched
                            binColorClassKey = 'default-recyclable'; // Fallback blue
                            binNameKey = 'binRecycling'; // Generic key
                            binIconClass = 'fa-recycle';
                            specificInstructionKey = 'instructionRecycling'; // Use generic instruction
                        }
                        break;
                    case 'organic':
                        binColorClassKey = 'br-organic';
                        binNameKey = 'binNameOrganicBR';
                        binIconClass = 'fa-leaf';
                        specificInstructionKey = 'instructionOrganicBR';
                        break;
                    case 'hazardous':
                        binColorClassKey = 'br-hazardous';
                        binNameKey = 'binNameHazardousBR';
                        binIconClass = 'fa-triangle-exclamation';
                        specificInstructionKey = 'instructionHazardousBR';
                        break;
                    default: // general-waste
                        binColorClassKey = 'br-general-waste';
                        binNameKey = 'binNameGeneralBR';
                        binIconClass = 'fa-trash-alt';
                        specificInstructionKey = 'instructionGeneralBR';
                }
            } else if (country === 'de') { // German Logic (Existing)
                switch(binType) {
                    case 'recyclable':
                        if (materialLower.includes('paper') || materialLower.includes('cardboard')) {
                            binColorClassKey = 'de-recyclable-paper';
                            binNameKey = 'binNameRecyclingDE_Blue';
                            binIconClass = 'fa-file-alt';
                            specificInstructionKey = 'instructionRecyclingDE_Blue';
                        } else { // Assume Yellow bin for other recyclables
                            binColorClassKey = 'de-recyclable-yellow';
                            binNameKey = 'binNameRecyclingDE_Yellow';
                            binIconClass = 'fa-recycle';
                            specificInstructionKey = 'instructionRecyclingDE_Yellow';
                        }
                        break;
                    case 'organic':
                        binColorClassKey = 'de-organic';
                        binNameKey = 'binNameOrganicDE';
                        binIconClass = 'fa-leaf';
                        specificInstructionKey = 'instructionOrganicDE';
                        break;
                    case 'hazardous':
                        binColorClassKey = 'de-hazardous';
                        binNameKey = 'binNameHazardousDE';
                        binIconClass = 'fa-triangle-exclamation';
                        specificInstructionKey = 'instructionHazardousDE';
                        break;
                    default: // general-waste
                        binColorClassKey = 'de-general-waste';
                        binNameKey = 'binNameGeneralDE';
                        binIconClass = 'fa-trash-alt';
                        specificInstructionKey = 'instructionGeneralDE';
                }
            } else if (country === 'it') { // Italian Logic (Existing)
                 switch(binType) {
                    case 'recyclable':
                        if (materialLower.includes('paper') || materialLower.includes('cardboard')) {
                            binColorClassKey = 'it-recyclable-paper';
                            binNameKey = 'binNameRecyclingIT_Blue';
                            binIconClass = 'fa-file-alt';
                            specificInstructionKey = 'instructionRecyclingIT_Blue';
                        } else if (materialLower.includes('glass')) {
                            binColorClassKey = 'it-recyclable-glass';
                            binNameKey = 'binNameRecyclingIT_Green';
                            binIconClass = 'fa-wine-bottle';
                            specificInstructionKey = 'instructionRecyclingIT_Green';
                        } else { // Assume Yellow bin for plastic/metal
                            binColorClassKey = 'it-recyclable-plastic_metal';
                            binNameKey = 'binNameRecyclingIT_Yellow';
                            binIconClass = 'fa-recycle';
                            specificInstructionKey = 'instructionRecyclingIT_Yellow';
                        }
                        break;
                    case 'organic':
                        binColorClassKey = 'it-organic';
                        binNameKey = 'binNameOrganicIT';
                        binIconClass = 'fa-leaf';
                        specificInstructionKey = 'instructionOrganicIT';
                        break;
                    case 'hazardous':
                        binColorClassKey = 'it-hazardous';
                        binNameKey = 'binNameHazardousIT';
                        binIconClass = 'fa-triangle-exclamation';
                        specificInstructionKey = 'instructionHazardousIT';
                        break;
                    default: // general-waste
                        binColorClassKey = 'it-general-waste';
                        binNameKey = 'binNameGeneralIT';
                        binIconClass = 'fa-trash-alt';
                        specificInstructionKey = 'instructionGeneralIT';
                }
            } else { // US or Default Logic (Existing)
                switch(binType) {
                    case 'recyclable':
                        binColorClassKey = 'us-recyclable';
                        binNameKey = 'binNameRecyclingUS'; // Use US as default naming scheme
                        binIconClass = 'fa-recycle';
                        specificInstructionKey = 'instructionRecyclingUS';
                        break;
                    case 'organic':
                        binColorClassKey = 'us-organic';
                        binNameKey = 'binNameOrganicUS';
                        binIconClass = 'fa-leaf';
                        specificInstructionKey = 'instructionOrganicUS';
                        break;
                    case 'hazardous':
                        binColorClassKey = 'us-hazardous';
                        binNameKey = 'binNameHazardousUS';
                        binIconClass = 'fa-triangle-exclamation';
                        specificInstructionKey = 'instructionHazardousUS';
                        break;
                    default: // general-waste
                        binColorClassKey = 'us-general-waste';
                        binNameKey = 'binNameGeneralUS';
                        binIconClass = 'fa-trash-alt';
                        specificInstructionKey = 'instructionGeneralUS';
                }
            }

            // Get Regional Bin Name (Use the region's specific translation, fallback to English for region, fallback to key)
            regionalBinName = t_region_specific?.[binNameKey]
                              || t_region_en[binNameKey]
                              || binNameKey;

            // Get UI language bin name (Use UI language, fallback to regional name)
            uiBinName = t_ui?.[binNameKey] || regionalBinName;

            return {
                binColorClassKey, // e.g., 'br-recyclable-paper'
                regionalBinName,  // Name in the region's typical language (from translations)
                uiBinName,        // Name in the selected UI language (from translations)
                binIconClass,
                headerMaterialSummary, // Material summary in UI language
                binNameKey, // e.g., 'binNameRecyclingBR_Paper'
                specificInstructionKey // e.g., 'instructionRecyclingBR_Paper'
            };
        }

        // Helper function to generate appropriate instruction text
        function generateInstructionText(item, details) {
            const t_ui = translations[currentLanguage] || translations.en;
            const t_region = translations[userCountry] || translations.en; // Translations for the *selected region*
            const { primaryBin, material, isContaminated } = item;
            const { regionalBinName, specificInstructionKey } = details;
            let instructionText = "";
            let targetBinName = regionalBinName; // Use the regional name in instructions by default

            // Handle contaminated recyclables specially - redirect to general waste
            if (isContaminated && primaryBin === 'recyclable') {
                // Determine the correct key for general waste bin name and contaminated instruction for the current country
                let generalBinKey = 'binNameGeneralUS'; // Default
                let contaminatedInstructionKey = 'instructionContaminatedRecyclableUS'; // Default
                if (userCountry === 'de') {
                    generalBinKey = 'binNameGeneralDE';
                    contaminatedInstructionKey = 'instructionContaminatedRecyclableDE';
                } else if (userCountry === 'it') {
                    generalBinKey = 'binNameGeneralIT';
                    contaminatedInstructionKey = 'instructionContaminatedRecyclableIT';
                } else if (userCountry === 'br') {
                    generalBinKey = 'binNameGeneralBR';
                    contaminatedInstructionKey = 'instructionContaminatedRecyclableBR';
                }

                // Get the name of the general waste bin in the region's language
                const generalBinName = t_region?.[generalBinKey]
                                       || translations.en[generalBinKey] // Fallback to English regional
                                       || t_ui.binGeneral; // Fallback to UI generic

                // Get the contaminated instruction text in the UI language
                instructionText = (t_ui?.[contaminatedInstructionKey] || translations.en[contaminatedInstructionKey])
                                    .replace('{binName}', generalBinName);
            } else {
                 // Use the specific instruction key determined by generateBinDetails
                 // Fetch instruction in UI language, fallback to English version of key, fallback to UI generic, absolute fallback
                 instructionText = t_ui?.[specificInstructionKey]
                                   || translations.en[specificInstructionKey]
                                   || t_ui.instructionGeneral // Generic UI fallback
                                   || "Place in the {binName}."; // Absolute fallback

                 // Replace placeholders
                 instructionText = instructionText.replace('{binName}', targetBinName);
                 // Use material name from UI language translations if available
                 const uiMaterialName = t_ui?.[`material${material?.charAt(0).toUpperCase() + material?.slice(1)}`] || material || 'material';
                 instructionText = instructionText.replace('{material}', uiMaterialName);
            }

             // Add a note to always check local guidelines
             const checkLocalText = t_ui?.instructionCheckLocal || translations.en.instructionCheckLocal;
             const searchItem = item.itemName || (material ? `${t_ui?.[`material${material?.charAt(0).toUpperCase() + material?.slice(1)}`] || material} item` : 'item');
             const countryNameElement = countrySelect.querySelector(`option[value="${userCountry}"]`);
             const countryName = countryNameElement ? countryNameElement.text : userCountry.toUpperCase(); // Get full country name or code
             const searchTerm = `${t_ui?.binRecycling || 'Recycling'} guidelines ${searchItem} ${countryName}`;
             const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(searchTerm)}`;
             instructionText += ` <a href="${searchUrl}" target="_blank" class="text-blue-600 hover:underline">(${checkLocalText})</a>`;

            return { instructionText };
        }

        function updateUIText(lang) {
            const t = translations[lang] || translations.en; // Fallback to English
            if (!t) {
                console.warn(`Language "${lang}" not found.`);
                return;
            }
            document.documentElement.lang = lang; // Set page language attribute
            document.getElementById('app-title-text').textContent = t.appTitle;
            document.getElementById('language-label').textContent = t.languageLabel;
            document.getElementById('country-label').textContent = t.countryLabel;
            document.getElementById('instructions-text').innerHTML = `<strong>${t.instructionsTitle || 'How to use:'}</strong> ${t.instructionsText || 'Point your camera...'}`;
            document.getElementById('scan-button-text').textContent = t.scanButtonText || 'Identify Item';
            document.getElementById('history-button-text').textContent = t.historyButtonText || 'Scan History';
            // Update modal title and empty message if modal elements exist
             const modalTitle = document.getElementById('history-modal-title');
             const emptyMsg = document.getElementById('history-empty-message');
             if(modalTitle) modalTitle.textContent = t.historyModalTitle || 'Scan History';
             if(emptyMsg) emptyMsg.textContent = t.historyEmptyMessage || 'No scans recorded yet.';

             // Update country names in dropdown to current language if available
             // This is a bit more complex as it requires mapping values to translated text
             // For simplicity, we'll keep the country dropdown text in English for now.
             // You could add a function here to iterate through countrySelect options
             // and update their text based on a translation map if needed.
        }

        // --- Display Results Function (Handles success and AI-reported failure) ---
        function displayAIResults(items) {
            hideSpinner(); // Hide spinner now that we have a response
            lastResultItems = items; // Store raw items array
            const t = translations[currentLanguage] || translations.en;

            // 1. Handle invalid input
            if (!items || !Array.isArray(items)) {
                console.error("displayAIResults called with invalid items data:", items);
                displayError("errorAIStructure");
                lastResultItems = null;
                return;
            }

            // 2. Handle empty list from AI
            if (items.length === 0) {
                 console.log("AI returned empty 'items' list.");
                 displayFailureResult(
                     t.errorAINoItemFound,
                     t.instructionError
                 );
                 lastResultItems = null;
                 return;
            }

            // --- Focus on the first item ---
            const item = items[0];

            // 3. Handle specific "error" bin case
            if (item.primaryBin === 'error') {
                 console.log("AI reported identification failure:", item.reasoning);
                 displayFailureResult(
                     item.itemName || t.binNameError,
                     item.reasoning || t.instructionError
                 );
                 lastResultItems = items; // Keep for debugging
                 // Do NOT save error to history (handled in saveResultToHistory)
                 return;
            }

            // --- Proceed with NORMAL item display ---
            const {
                itemName: detectedItemName,
                primaryBin,
                primaryConfidence,
                secondaryBin,
                secondaryConfidence,
                material,
                reasoning,
                isContaminated,
                position
            } = item;

            // Generate details based on the identification
            const details = generateBinDetails(primaryBin, material, userCountry);
            const { binColorClassKey, regionalBinName, uiBinName, binIconClass, headerMaterialSummary, specificInstructionKey } = details;

            // Get Tailwind classes
            const bgColorClass = binColorClasses[binColorClassKey] || binColorClasses['default-general-waste'];
            const borderColorClass = binBorderColorClasses[binColorClassKey] || binBorderColorClasses['default-general-waste'];

            // --- Update Header ---
            binHeader.className = `bin-header flex flex-col items-center justify-center p-6 text-white text-center min-h-[180px] ${bgColorClass}`;
            binHeader.innerHTML = `
                <i class="fas ${binIconClass} fa-3x mb-3"></i>
                <span class="block text-2xl font-bold leading-tight bin-name-region">${regionalBinName}</span>
                ${ currentLanguage !== userCountry && uiBinName !== regionalBinName ? `<span class="block text-sm opacity-80 mt-1 bin-name-ui-lang">(${uiBinName})</span>` : '' }
                <div class="bin-material text-sm font-medium mt-2 opacity-90">${headerMaterialSummary}</div>
            `;

            // --- Update Item Details ---
            itemName.textContent = detectedItemName || t.materialMixed || "Identified Item"; // Use generic name if AI fails

            // Clear previous dynamic content
            const detailsContainer = document.querySelector('.item-details');
            const oldDynamicElements = detailsContainer.querySelectorAll('.dynamic-result-element');
            oldDynamicElements.forEach(el => el.remove());

            let lastInsertedElement = itemName;

            // Confidence Score
            const confidenceEl = createDynamicElement('item-confidence', 'text-sm text-gray-600 mt-1 mb-3');
            confidenceEl.innerHTML = `<strong>${t.aiConfidencePrefix}</strong> ${Math.round((primaryConfidence || 0) * 100)}%`;
            lastInsertedElement.insertAdjacentElement('afterend', confidenceEl);
            lastInsertedElement = confidenceEl;

            // Secondary Guess
            if (secondaryBin && secondaryConfidence && secondaryConfidence > 0.1) {
                 // Get the name for the secondary bin suggestion based on current settings
                const { regionalBinName: secondaryRegionalName } = generateBinDetails(secondaryBin, null, userCountry);
                const secondaryGuessEl = createDynamicElement('item-secondary-guess', 'text-sm text-gray-500 mb-3');
                secondaryGuessEl.innerHTML = `<strong>${t.aiSecondaryGuessPrefix}</strong> ${secondaryRegionalName} (${Math.round(secondaryConfidence * 100)}%)`;
                lastInsertedElement.insertAdjacentElement('afterend', secondaryGuessEl);
                lastInsertedElement = secondaryGuessEl;
            }

             // --- Update Instructions ---
             const { instructionText: generatedInstructionText } = generateInstructionText(item, details);
             binInstructions.innerHTML = generatedInstructionText;
             binInstructions.className = `bin-instructions text-base font-medium mt-4 mb-3 p-4 rounded-r-md border-l-4 ${borderColorClass}`;
             binInstructions.style.display = 'block';
             detailsHr.style.display = 'block';
             lastInsertedElement = binInstructions; // Insert after instructions

             // --- AI Reasoning / Description ---
             itemDescription.textContent = `${t.aiAnalysisPrefix} ${reasoning || 'N/A'}`;
             itemDescription.style.display = 'block';
             lastInsertedElement.insertAdjacentElement('afterend', itemDescription); // Insert desc after instructions
             lastInsertedElement = itemDescription;

            // --- Contamination Warning ---
             if (isContaminated) {
                 const contaminationEl = createDynamicElement('contamination-warning', 'bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-2 rounded relative text-sm mt-4');
                 contaminationEl.innerHTML = `<i class="fa-solid fa-triangle-exclamation mr-1"></i> ${t.aiContaminatedWarning}`;
                 lastInsertedElement.insertAdjacentElement('afterend', contaminationEl);
                 lastInsertedElement = contaminationEl;
             }

            // --- Position Info ---
             if (position) {
                 const positionEl = createDynamicElement('item-position', 'text-xs text-gray-500 mt-3');
                 positionEl.innerHTML = `<strong>${t.aiPositionPrefix}</strong> ${position}`;
                 lastInsertedElement.insertAdjacentElement('afterend', positionEl);
                 lastInsertedElement = positionEl;
             }

            // --- Multiple Items Note ---
            if (items.length > 1) {
                 const multiItemsEl = createDynamicElement('multi-items-note', 'bg-blue-100 border border-blue-400 text-blue-700 px-4 py-2 rounded relative text-sm mt-4');
                 multiItemsEl.innerHTML = `<i class="fa-solid fa-circle-info mr-1"></i> ${t.multipleItemsDetected}`;
                 lastInsertedElement.insertAdjacentElement('afterend', multiItemsEl);
                 lastInsertedElement = multiItemsEl;
            }

             // --- Feedback Buttons ---
             const feedbackEl = createDynamicElement('feedback-container', 'text-center mt-6 mb-2');
             feedbackEl.innerHTML = `
                 <span class="text-sm text-gray-600 mr-3">Was this helpful?</span>
                 <button class="px-3 py-1 bg-green-100 text-green-700 text-sm font-medium rounded-md hover:bg-green-200 transition mr-2" onclick="handleFeedback(true)">
                     <i class="fa-solid fa-check mr-1"></i> ${t.feedbackCorrect}
                 </button>
                 <button class="px-3 py-1 bg-red-100 text-red-700 text-sm font-medium rounded-md hover:bg-red-200 transition" onclick="handleFeedback(false)">
                      <i class="fa-solid fa-xmark mr-1"></i> ${t.feedbackIncorrect}
                 </button>
             `;
             countryNote.insertAdjacentElement('beforebegin', feedbackEl); // Insert before the hidden country note

            // --- Show Card and Scroll ---
            resultCard.classList.remove('hidden');
            resultCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // --- Save *successful* result to history ---
            saveResultToHistory(item, lastImageDataUrl);
        }

        // Helper to create dynamic elements consistently
        function createDynamicElement(id, classNames) {
            const el = document.createElement('div');
            el.id = id;
            el.className = `dynamic-result-element ${classNames}`;
            return el;
        }

        // --- Function to display the "Identification Failed" state in the card ---
        function displayFailureResult(failureName, failureReasoning) {
            const t = translations[currentLanguage] || translations.en;

            const bgColorClass = binColorClasses['error-bin'];
            const borderColorClass = binBorderColorClasses['error-bin'];

            binHeader.className = `bin-header flex flex-col items-center justify-center p-6 text-white text-center min-h-[180px] ${bgColorClass}`;
            binHeader.innerHTML = `
                <i class="fas fa-question-circle fa-3x mb-3"></i>
                <span class="block text-2xl font-bold leading-tight bin-name-region">${failureName}</span>
                <div class="bin-material text-sm font-medium mt-2 opacity-90"></div>
            `;

            itemName.textContent = failureName;

            const detailsContainer = document.querySelector('.item-details');
            const oldDynamicElements = detailsContainer.querySelectorAll('.dynamic-result-element');
            oldDynamicElements.forEach(el => el.remove());

            binInstructions.style.display = 'none';
            detailsHr.style.display = 'none';

            itemDescription.textContent = failureReasoning;
            itemDescription.style.display = 'block';

            resultCard.classList.remove('hidden');
            resultCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }


        // Placeholder for feedback handling
        function handleFeedback(isCorrect) {
            console.log("Feedback received:", isCorrect ? "Correct" : "Incorrect");
            const feedbackContainer = document.getElementById('feedback-container');
            if (feedbackContainer) {
                feedbackContainer.innerHTML = `<small class="text-gray-600">Thank you for your feedback!</small>`;
            }
            // TODO: Send feedback data (maybe including lastAIResponse and user selection)
        }

        // --- History Functions ---
        const HISTORY_KEY = 'trashSeparatorHistory_v2';

        function saveResultToHistory(itemData, imageDataUrl) {
            if (!itemData || itemData.primaryBin === 'error' || !imageDataUrl) {
                console.warn("Skipping saving error or incomplete result to history.");
                return;
            }

            const history = loadHistory();
            const timestamp = new Date().toISOString();
            const historyEntry = {
                id: timestamp + '-' + Math.random().toString(36).substr(2, 9),
                timestamp,
                item: {
                    itemName: itemData.itemName,
                    primaryBin: itemData.primaryBin,
                    primaryConfidence: itemData.primaryConfidence,
                    material: itemData.material,
                },
                image: imageDataUrl, // Consider reducing size/quality here if storage becomes an issue
                language: currentLanguage, // Save language used for this result
                region: userCountry // Save region used for this result
            };
            history.unshift(historyEntry); // Add to the beginning
            while (history.length > 50) { history.pop(); } // Limit size

            try {
                localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
            } catch (e) {
                console.error("Error saving history to localStorage:", e);
                if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                    alert("History storage is full. Older items may be removed.");
                    // Try removing more items aggressively
                    history.splice(40);
                    try { localStorage.setItem(HISTORY_KEY, JSON.stringify(history)); } catch (e2) {}
                }
            }
        }

        function loadHistory() {
            try {
                const historyJson = localStorage.getItem(HISTORY_KEY);
                return historyJson ? JSON.parse(historyJson) : [];
            } catch (e) {
                console.error("Error loading history from localStorage:", e);
                localStorage.removeItem(HISTORY_KEY); // Clear potentially corrupted history
                return [];
            }
        }

        // --- History Modal Functions ---
        function toggleHistoryModal(show) {
            if (show) {
                displayHistory();
                historyModal.classList.remove('hidden');
                historyModal.classList.add('flex');
            } else {
                historyModal.classList.add('hidden');
                historyModal.classList.remove('flex');
            }
        }

        function displayHistory() {
            const history = loadHistory();
            const modalBody = document.getElementById('history-modal-body');
            const emptyMsgElement = document.getElementById('history-empty-message'); // Get ref to empty msg P tag

            // Clear previous items *except* the empty message structure
             modalBody.querySelectorAll('.history-item').forEach(item => item.remove());

             // Update empty message text based on current language
             emptyMsgElement.textContent = translations[currentLanguage].historyEmptyMessage || 'No scans recorded yet.';

            if (history.length === 0) {
                emptyMsgElement.classList.remove('hidden'); // Show message
                return;
            }

            emptyMsgElement.classList.add('hidden'); // Hide message

            history.forEach(entry => {
                 // Generate bin details based on the STORED entry's region and bin type
                 const entryRegion = entry.region || 'us'; // Use saved region or default
                 const entryLang = entry.language || 'en'; // Use saved language or default
                 const entry_t = translations[entryLang] || translations.en; // Translations matching the entry's context

                 // Generate bin details using the entry's specific context
                 const { regionalBinName: entryBinName } = generateBinDetails(entry.item.primaryBin, entry.item.material, entryRegion);

                 // Get material name in the entry's language for display
                 const entryMaterialName = entry.item.material
                    ? (entry_t[`material${entry.item.material.charAt(0).toUpperCase() + entry.item.material.slice(1)}`] || entry.item.material)
                    : '';

                 const itemDiv = document.createElement('div');
                 itemDiv.className = 'history-item flex items-center border-b border-gray-200 py-3 last:border-b-0'; // Add class for easy clearing

                 const img = document.createElement('img');
                 img.src = entry.image;
                 img.className = 'history-thumbnail w-16 h-16 object-cover mr-4 rounded-md border border-gray-200 flex-shrink-0';
                 img.alt = entry.item.itemName || 'Scanned item';
                 img.loading = 'lazy'; // Lazy load images

                 const detailsDiv = document.createElement('div');
                 detailsDiv.className = 'history-details flex-grow';

                 detailsDiv.innerHTML = `
                    <strong class="block text-sm font-semibold text-gray-800 mb-0.5">${entry.item.itemName || (entry_t.materialMixed || 'Unknown Item')}</strong>
                    <span class="block text-xs text-gray-600">Result (${entryRegion.toUpperCase()}): ${entryBinName}</span>
                    ${entryMaterialName ? `<span class="block text-xs text-gray-600">Material: ${entryMaterialName}</span>` : ''}
                    <span class="block text-xs text-gray-600">Confidence: ${Math.round((entry.item.primaryConfidence || 0) * 100)}%</span>
                    <span class="block text-xs text-gray-400 mt-1">${new Date(entry.timestamp).toLocaleString(currentLanguage)}</span>
                 `; // Display timestamp using CURRENT UI language format

                 itemDiv.appendChild(img);
                 itemDiv.appendChild(detailsDiv);
                 modalBody.appendChild(itemDiv); // Append the new item
            });
        }

        // Close modal if user clicks outside of the modal content
        historyModal.addEventListener('click', function(event) {
            if (event.target === historyModal) {
                 toggleHistoryModal(false);
            }
        });


        // --- Event Listeners ---
        historyButton.addEventListener('click', () => toggleHistoryModal(true));

        languageSelect.addEventListener('change', (event) => {
            currentLanguage = event.target.value;
            updateUIText(currentLanguage);
             if (lastResultItems && !resultCard.classList.contains('hidden')) {
                 // Re-render the currently displayed result with new language texts
                 displayAIResults(lastResultItems);
             }
        });

        countrySelect.addEventListener('change', (event) => {
            userCountry = event.target.value;
             if (lastResultItems && !resultCard.classList.contains('hidden')) {
                 // Re-render the currently displayed result with new country rules/names
                 displayAIResults(lastResultItems);
             }
        });

        // --- Scan Button Action ---
        scanButton.onclick = function () {
            showSpinner();
            try {
                // Snapshot visual feedback
                const cameraContainer = document.getElementById('camera-container');
                const snapshotOverlay = document.createElement('canvas');
                snapshotOverlay.width = cameraContainer.clientWidth;
                snapshotOverlay.height = cameraContainer.clientHeight;
                snapshotOverlay.className = 'absolute inset-0 z-10 bg-white bg-opacity-50 transition-opacity duration-400 ease-out';
                snapshotOverlay.style.opacity = '1';
                const snapContext = snapshotOverlay.getContext('2d');
                // Draw current video frame to hidden canvas first
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                // Get data URL from hidden canvas
                const imageData = canvas.toDataURL('image/png');
                lastImageDataUrl = imageData; // Store for history
                // Draw onto snapshot overlay for visual effect
                snapContext.drawImage(video, 0, 0, snapshotOverlay.width, snapshotOverlay.height);
                cameraContainer.appendChild(snapshotOverlay);
                setTimeout(() => {
                    snapshotOverlay.style.opacity = '0';
                    setTimeout(() => { if (snapshotOverlay.parentNode === cameraContainer) { cameraContainer.removeChild(snapshotOverlay); } }, 400);
                }, 150);

                // --- AI Prompt (Unchanged, but mentioning Brazil might help AI) ---
                const prompt = `Analyze the item(s) in the image for waste sorting purposes based on common recycling rules (consider US, German, Italian, Brazilian variations if possible, but prioritize general rules). Identify the primary item(s). For each item identified, provide:
1.  \`itemName\`: A concise name for the item (e.g., "Plastic Bottle", "Aluminum Can").
2.  \`primaryBin\`: The most likely disposal bin type ('recyclable', 'organic', 'general-waste', 'hazardous').
3.  \`primaryConfidence\`: Confidence score (0.0 to 1.0) for the primaryBin.
4.  \`secondaryBin\`: Next likely bin type.
5.  \`secondaryConfidence\`: Confidence score (0.0 to 1.0) for secondaryBin.
6.  \`material\`: Specific material if identifiable (e.g., 'PET', 'Aluminum', 'Paper', 'Glass', 'Plastic').
7.  \`reasoning\`: Brief explanation for the primaryBin choice.
8.  \`isContaminated\`: Boolean (true/false) indicating likely contamination (e.g., food residue).
9.  \`position\`: Approximate position in image (e.g., 'center', 'top-left').

**IMPORTANT:** Return the response ONLY as a valid JSON object containing a list called "items".
*   If you successfully identify one or more items, list them in the "items" array.
*   **If you cannot confidently identify any item suitable for sorting, return a single item object in the list like this:**
    \`\`\`json
    {
      "items": [
        {
          "itemName": "Identification Failed",
          "primaryBin": "error",
          "primaryConfidence": 0.0,
          "secondaryBin": null,
          "secondaryConfidence": 0.0,
          "material": null,
          "reasoning": "Could not recognize a distinct item clearly enough for sorting. Please try again with a clearer image or different angle.",
          "isContaminated": false,
          "position": "unknown"
        }
      ]
    }
    \`\`\`
*   Do not include any text before or after the JSON object.

Example for a successful identification:
{
  "items": [
    {
      "itemName": "Aluminum Can",
      "primaryBin": "recyclable",
      "primaryConfidence": 0.98,
      "secondaryBin": "general-waste",
      "secondaryConfidence": 0.02,
      "material": "Aluminum",
      "reasoning": "Clean aluminum can, typically recyclable.",
      "isContaminated": false,
      "position": "center"
    }
  ]
}`;

                console.log("Sending prompt to AI...");
                puter.ai.chat(prompt, imageData)
                    .then(response => {
                        console.log("Raw AI Response Received:", response);
                        let aiResult;
                        let responseContent = '';
                        try {
                            if (typeof response === 'string') {
                                responseContent = response;
                            } else if (typeof response === 'object' && response !== null) {
                                responseContent = response.content || response.text || (response.message && response.message.content) || JSON.stringify(response); // Handle various structures
                            } else { throw new Error("Unexpected AI response format."); }

                            responseContent = String(responseContent).trim().replace(/^```json\s*|```$/g, '').trim();

                            if (!responseContent) { throw new Error("Received empty content from AI after cleaning."); }

                            aiResult = JSON.parse(responseContent);
                            console.log("Parsed AI Result:", aiResult);

                            if (!aiResult || typeof aiResult !== 'object' || !Array.isArray(aiResult.items)) {
                                throw new Error("Invalid JSON structure: 'items' array not found or invalid.");
                            }

                            lastAIResponse = aiResult;
                            displayAIResults(aiResult.items);

                        } catch (parseError) {
                            console.error('AI Processing/Parsing Error:', parseError);
                            console.error('Problematic AI Response Content:', responseContent);
                            const currentLang = languageSelect.value || 'en'; // Get current lang for error msg
                            displayError("errorAIStructure", `${parseError.message}. Response: ${responseContent.substring(0, 100)}...`);
                            lastResultItems = null;
                            lastAIResponse = null;
                        }
                    })
                    .catch(error => {
                        console.error('AI Call Error:', error);
                        const currentLang = languageSelect.value || 'en';
                        displayError("errorAIAnalyze", error.message || (translations[currentLang]?.errorUnknownAI || 'Unknown AI error.'));
                        lastResultItems = null;
                        lastAIResponse = null;
                    })
                    .finally(() => {
                        // Spinner is managed by displayAIResults/displayError
                        scanButton.disabled = false;
                    });

            } catch (error) {
                 console.error("Error during capture/AI call setup:", error);
                 const currentLang = languageSelect.value || 'en';
                 displayError("errorCapture", error.message);
                 hideSpinner(); // Ensure spinner hidden if setup fails
                 lastResultItems = null;
                 lastAIResponse = null;
            }
        };


        // --- Country/region detection ---
         async function detectUserCountry() {
            try {
                // Prefer Puter Geo API if available
                if (puter?.geo?.get) {
                     const geoInfo = await puter.geo.get();
                     if (geoInfo?.countryCode) {
                        const country = geoInfo.countryCode.toLowerCase();
                         console.log("Country detected via Puter Geo:", country);
                          if (['us', 'de', 'it', 'br'].includes(country)) return country; // Added 'br'
                     }
                }

                // Fallback to ipapi.co
                const response = await fetch('https://ipapi.co/json/');
                if (!response.ok) throw new Error(`ipapi.co failed: ${response.status}`);
                const data = await response.json();
                if (data?.country_code) {
                    const country = data.country_code.toLowerCase();
                    console.log("Country detected via IP:", country);
                    if (['us', 'de', 'it', 'br'].includes(country)) return country; // Added 'br'
                }
            } catch (e) {
                console.warn("IP/Puter geolocation failed:", e);
            }

            // Fallback to browser locale (less reliable for country)
            try {
                const browserLocale = navigator.language || navigator.userLanguage;
                if (browserLocale) {
                    const localeParts = browserLocale.split('-');
                    if (localeParts.length > 1) {
                        const country = localeParts[1].toLowerCase();
                        console.log("Trying country from browser locale:", country);
                         if (['us', 'de', 'it', 'br'].includes(country)) return country; // Added 'br'
                    }
                }
            } catch (e) {
                console.warn("Browser locale detection failed:", e);
            }

            console.log("Using default country: us");
            return 'us'; // Default if all else fails
        }

        // --- Camera Initialization Function ---
        async function initApp() {
             console.log("Initializing app...");

             // 1. Detect country and set dropdown
             try {
                 const detectedCountry = await detectUserCountry();
                 const countryOption = countrySelect.querySelector(`option[value="${detectedCountry}"]`);
                 if (countryOption) {
                     countrySelect.value = detectedCountry;
                     userCountry = detectedCountry;
                 } else {
                     userCountry = countrySelect.value; // Use default if detection fails or unsupported
                 }
                 console.log("Initial country set to:", userCountry.toUpperCase());
             } catch (err) {
                 console.error("Failed to set initial country:", err);
                 userCountry = countrySelect.value; // Ensure default is set on error
             }

             // 2. Set up canvas size
             canvas.width = 640;
             canvas.height = 480;

             // 3. Initialize translations for default language (English initially)
             // The language dropdown change listener will handle subsequent updates.
             updateUIText(currentLanguage);

             // 4. Initialize Camera
             if (navigator.mediaDevices?.getUserMedia) {
                 try {
                     const stream = await navigator.mediaDevices.getUserMedia({
                         video: {
                             facingMode: "environment",
                             width: { ideal: 1280 },
                             height: { ideal: 720 },
                         }
                     });
                     video.srcObject = stream;
                     video.onloadedmetadata = function(e) {
                         video.play().catch(playError => {
                              console.error("Video play failed:", playError);
                              video.muted = true; // Try muted play as fallback
                              video.play().catch(e2 => console.error("Muted play failed:", e2));
                         });
                         const track = stream.getVideoTracks()[0];
                         const settings = track.getSettings();
                         const aspectRatio = settings.width / settings.height;
                         canvas.height = canvas.width / aspectRatio; // Adjust canvas height to match video aspect ratio
                         console.log(`Camera initialized (${settings.width}x${settings.height}), canvas aspect ratio adjusted`);
                         scanButton.disabled = false; // Enable scan button
                     };
                 } catch (error) {
                     console.error("Camera access error:", error);
                     let errorKey = "errorCameraInit";
                     if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
                         errorKey = "errorCameraNotFound";
                     } else if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
                         errorKey = "errorCameraDenied";
                     }
                     displayError(errorKey, `(${error.name})`);
                 }
             } else {
                 displayError("errorCameraInit", "getUserMedia() is not supported.");
             }
        }

        // --- Start the app ---
        initApp();

    </script>
</body>
</html>